---
description: 从并发与操作系统的学习视角出发，介绍网页运行中“看似多线程”的原因，并解释浏览器与 JavaScript 之间的真实协作方式。
date: '2025-12-08'
author: 'pxx'
categories:
  - Web
published: true
---



# 为什么网页看起来像多线程

在学习并发与操作系统执行模型的过程中，我对网页在实际运行时表现出的“似乎可以同时处理多件事”的现象产生了疑问。浏览器能够在播放动画的同时处理用户输入，又能并行进行网络请求，这种行为与我在操作系统课程中理解的单线程模型并不一致：多个任务能并行执行，不相互阻塞，看起来就像多个线程一起跑。当我查阅资料之后发现：**大多数网页的 JavaScript 实际上是单线程运行的**。为了弄清楚这一现象的来源，我查阅了浏览器线程结构、事件循环机制以及 Web Worker 的相关实现，并将理解过程整理成这篇文章，以便将这一概念从表面现象拆解到实际运行机制。

为什么我们仍然觉得它像是多线程？这一切得从浏览器的设计说起。网页虽然看上去统一运行在一个界面中，但它内部的运作更像是一个“小型操作系统”：有负责执行脚本的线程，有负责处理网络请求的线程，也有渲染管线在处理布局和绘制。从工程实践的角度来看，这种错觉不是坏事。相反，它为开发者提供了一种非常舒适的编程体验——在不需要考虑锁、死锁或竞争条件的前提下，仍然能享受“不阻塞”的效果。

## JavaScript：单线程语言在网页中的执行模型

当你第一次听到“JavaScript 是单线程的”时，往往会本能地皱眉：现代网页要处理的事情这么多，一个单线程语言怎么可能撑起整个交互体系？如果从工程角度看，这几乎与我们平日里开发后台系统或客户端程序时的直觉完全相反。

不过，JavaScript 的单线程设计并不是一种限制，它更像是一种**刻意的约束**。这种约束最早来自浏览器早期的安全模型——如果多个脚本能同时读写 DOM，那么就会出现类似操作系统开发中最头疼的竞争条件、资源抢占、锁管理等问题。那时候的网页开发者可没有准备好面对多线程带来的复杂性。

因此，浏览器团队做了一个更偏工程现实的选择：**让 JavaScript 保持单线程，让开发者不必操心同步问题，而复杂的调度与并发由浏览器去负责。**

从实践上来看，这种单线程模型不仅没有限制 JS 的能力，反而形成了一个简洁、可预测、避免数据竞争的执行环境。你写的代码永远按顺序运行，不需要考虑线程安全；你注册的事件处理函数，只会在主线程空闲时被调用；你可以专注逻辑层，而不用设计锁与队列。

站在工程经验的角度，这其实是一种非常聪明的取舍：通过降低语言和开发者的负担，将复杂性隐藏在浏览器内部，以换取更稳定、更安全的网页行为。在下一章中，我们会看到浏览器是如何在内部使用多线程来“弥补”这个限制的，让单线程的 JavaScript 看起来一点都不孤单。

## 浏览器的多线程结构及其协作方式

浏览器在内部使用多线程结构来处理网页运行过程中出现的各种任务。虽然 JavaScript 代码在单一主线程中执行，但浏览器会将许多与计算无关的工作交给其他线程，这些线程包含网络处理、计时器、渲染、解码等功能模块。这样做的目的，是避免将所有工作集中在主线程上，从而减少阻塞，提升交互流畅度。

为了更清晰地展示这些线程之间的协作关系，可以参考以下流程示意：

```
           +-------------------+
           |  JS 主线程（执行） |
           +-------------------+
                     |
        --------------------------------
        |              |               |
+---------------+ +-------------+ +---------------+
| 网络线程      | | 定时器线程 | | 渲染线程       |
| (XHR/Fetch)  | | (setTimeout)| | (布局/绘制)    |
+---------------+ +-------------+ +---------------+
        |              |               |
        +--------------+---------------+
                       |
               回调加入任务队列
                       |
               JS 主线程空闲时再执行
```

从图中可以看到：
- JavaScript 主线程专注于运行脚本；
- 网络线程负责执行网络请求及响应处理；
- 定时器线程负责计时功能；
- 渲染线程处理布局、绘制、样式计算等任务。

这些后台线程在任务完成后并不会直接执行回调，而是将回调函数放入任务队列中，等待主线程空闲时再统一调度执行。这种机制避免了主线程因等待 I/O 或渲染操作而停滞。

示例代码如下：

```js
document.querySelector("button").addEventListener("click", () => {
    console.log("按钮被点击了！");
});

fetch("/api/data").then(res => res.json()).then(data => {
    console.log("数据加载完成", data);
});
```

在上述示例中：
- 按钮点击事件监听器只需注册，事件触发后才进入任务队列；
- `fetch()` 请求由网络线程执行；
- 网络响应完成后，回调任务被加入队列等待执行；
- JavaScript 主线程在空闲时按序调用这些回调。

浏览器多线程架构的存在，使得网页在处理输入、渲染、网络等事务时不会出现明显阻塞。理解这一点有助于在工程实践中更好地进行性能分析。当页面出现卡顿时，问题通常并非浏览器本身线程调度不佳，而是主线程上存在过长的计算任务，造成事件与回调无法按时处理。

## 事件循环：网页保持连续响应的机制

JavaScript 采用事件循环（Event Loop）模型执行异步任务。该模型的基本运行流程如下：

主线程执行 JavaScript → 调用异步 API → 浏览器后台线程处理对应任务 → 任务完成后将回调加入事件队列 → 主线程空闲时从队列中取出并执行回调。

这一流程确保了主线程不会因等待某个耗时操作而停止执行，使网页保持连续响应能力。

以下示例体现了事件循环的典型行为：

```js
setTimeout(() => console.log("timeout"), 1000);
console.log("sync");
```

输出顺序为：
```
sync
timeout
```

其原因如下：
- `setTimeout` 不会阻塞主线程；
- 计时由浏览器的后台计时器线程处理；
- 主线程继续执行同步代码；
- 计时结束后，回调被加入事件队列；
- 主线程空闲时从队列中取回该回调并执行。

网页的“非阻塞性”来源于此事件循环机制。只要主线程未被长时间占用，浏览器即可在恰当的时机处理回调与用户交互事件。理解这一点对于调试页面性能具有重要意义：当出现明显卡顿时，问题往往源自主线程被占满，而不是事件循环本身的延迟。

## Web Worker：在需要多线程时的使用方式

在浏览器环境中，JavaScript 主线程承担了绝大多数逻辑，包括脚本执行、事件处理和部分渲染协调。当某些计算任务的执行时间较长时，主线程会被完全占用，从而影响输入响应和视觉更新。为了避免这种情况，浏览器提供了 Web Worker 作为补充，使开发者能够将某些任务移入独立线程执行，在多核 CPU 上获得额外的计算能力。

Web Worker 与主线程之间的关系比较明确：两者相互独立，彼此的执行互不干扰，通过消息机制进行数据传递。由于 Worker 无法访问 DOM，其适用范围集中在那些与页面结构无关、又具有较大计算量的操作上。例如，复杂的数值处理、数据解析、加密运算或图像处理等任务，可以在 Worker 中执行，从而避免主线程因长时间运行一段代码而阻塞事件循环。

以下示例描述了主线程与 Worker 的协作方式：

主线程：
```js
const worker = new Worker("worker.js");
worker.postMessage({ value: 100000 });
worker.onmessage = (e) => {
    console.log("结果：", e.data);
};
```

Worker（worker.js）：
```js
self.onmessage = (e) => {
    const input = e.data.value;
    let sum = 0;
    for (let i = 0; i < input; i++) sum += i;
    postMessage(sum);
};
```

在此过程中，主线程创建 Worker，并将任务参数发送给它；Worker 在独立线程中执行循环计算，完成后将结果返回给主线程。整个过程中，主线程保持空闲，可以处理用户输入或界面更新，不会因为计算任务而产生延迟感。

从实际开发经验来看，并非所有计算量大的任务都必须放入 Worker 中。是否使用 Worker 通常需要根据页面的响应情况来判断。当页面在滚动、输入、动画或其他交互中出现明显停顿时，就需要考虑是否有代码占用了主线程过久。如果这些任务能够独立执行且无需访问 DOM，那么将它们迁移至 Worker 通常会带来较明显的性能改善。

## 越来越多厂商选择以网页替代传统 App

近年来，一个明显的趋势出现在各类消费电子产品中：许多厂商不再优先提供独立的桌面或移动应用，而是转向以网页形式提供设备管理界面。例如，键盘与鼠标的驱动配置、路由器管理面板、蓝牙设备调试工具等，都越来越常见地以 Web 页面作为主要入口。

造成这一趋势的原因主要包括以下几点：

首先，Web 能够天然跨平台。厂商不必为 Windows、macOS、Linux、iOS、Android 分别维护多套应用，也无需适配不同的包格式与系统政策，仅需保证浏览器兼容性即可。对于硬件厂商而言，这能显著降低开发成本与维护负担。

其次，现代浏览器提供了越来越完善的设备访问能力，包括 WebUSB、WebHID、WebBluetooth 等接口，使网页也能与外设进行直接通信。过去必须通过原生应用完成的硬件管理任务，现在可以通过网页实现，并且开发与调试流程更加统一和透明。

此外，网页的更新成本远低于应用程序。厂商无需等待用户手动更新，也无需通过各平台商店的审核流程，只需部署新版本即可使所有用户自动获得最新功能。对硬件厂商来说，这是一种更可控且更敏捷的发布模式。

但这一模式也并非没有代价。网页仍然无法完全替代原生应用，例如访问权限受限、性能不及本地代码、对浏览器特性的依赖较强，以及在离线环境中的可用性不足。这些都使得网页方案更适合作为轻量级的设备管理界面，而不适合承担复杂或高性能需求的应用逻辑。

