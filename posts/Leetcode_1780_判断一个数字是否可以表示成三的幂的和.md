---
description: 进制转换判断方法和01背包法
date: '2025-08-14'
author: 'pxx'
categories:
  - Algorithms
published: true
---

# 判断一个数字是否可以表示成三的幂的和（LeetCode 1780）

## 问题描述

给定一个整数 `n`，判断它是否可以表示成**若干个不同的 3 的幂**的和。
 要求：

- 每个 3 的幂只能用一次（即幂次不能重复）。
- 1 ≤ n ≤ 10⁷。

例子：

```
n = 12 → true   (12 = 3¹ + 3²)
n = 91 → true   (91 = 3⁰ + 3² + 3⁴)
n = 21 → false
```

## 方法一：3 进制表示法（数学解法）

### 思路

题目要求：

- 用 **不同** 的 3 的幂相加得到 `n`。
- “不同”意味着：同一个幂次的 3 不能出现两次，比如 3² 不能加两遍。

换成 3 进制语言：

- 3⁰ 对应 3 进制个位
- 3¹ 对应 3 进制十位
- 3² 对应 3 进制百位
- …
   每个幂次只能出现 0 次或 1 次 → **这一位的数字只能是 0 或 1**。

所以如果一个数能由**不同的 3 的幂**相加得到，那么它的**3 进制表示中每一位只能是 0 或 1**，不能出现 2。

- 例如：
  - 12 = `110`₃（符合条件，位数只有 0/1）
  - 21 = `210`₃（不符合，有一位是 2）

### 步骤

1. 不断除以 3，检查余数是否大于 1。
2. 如果出现余数为 2，直接返回 `false`。
3. 否则一直除到 0 返回 `true`。

### 代码

```cpp
class Solution {
public:
    bool checkPowersOfThree(int n) {
		while(n){
			if(n % 3 == 2){
				return false;
			}
			n /= 3;
		}	
		return true;
    }
};

```

### 复杂度

- 时间复杂度：O(log₃ n)
- 空间复杂度：O(1)



## 方法二：01 背包法（动态规划解法）

### 背景

01 背包问题的模型：

- 给你若干物品（每个只能选一次），每个物品有一个价值。
- 背包容量为 `n`，问能否恰好装满。

在本题中：

- **物品**：每个物品的价值是 3 的幂（3⁰, 3¹, 3², …）。
- **容量**：`n`。
- **目标**：判断是否能用若干不同的 3 的幂凑成 `n`。

### 动态规划思路

1. `dp[i]` 表示容量为 `i` 是否能被恰好凑出（或方法数）。

2. 初始状态：`dp[0] = 1`（容量为 0 表示啥都不选）。

3. 遍历每个物品（3⁰, 3¹, … ≤ n），用**倒序遍历**更新 `dp`：

   ```java
   for (int j = n; j >= pow3; j--) {
       dp[j] = dp[j] + dp[j - pow3];
   }
   ```

   倒序的原因：防止一个物品被重复使用。

   **转移公式解释**：

   - `dp[j]` 表示容量为 `j` 的方案数（或者可行性标记）。
   - `dp[j - pow3]` 表示：如果容量 `j - pow3` 能被凑出来，那么加上这个物品（`3^i`）就能凑成容量 `j`。
   - `dp[j] = dp[j] + dp[j - pow3]` 就是在**累加可行方案数**。
     - 如果用布尔值（`dp[j] |= dp[j - pow3]`）就是判断可行性。
     - 这里用整数，是因为想记录方案数。

4. 如果 `dp[n] > 0`，说明至少存在一种方案可以用若干不同的 3 的幂凑出 `n`。

以`n=12`为例子：

```
物品↓ / 容量→   |  0  1  2  3  4  5  6  7  8  9 10 11 12
-------------------------------------------------------
初始           |  1  0  0  0  0  0  0  0  0  0  0  0  0
加入 1         |  1  1  0  0  0  0  0  0  0  0  0  0  0
加入 3         |  1  1  0  1  1  0  0  0  0  0  0  0  0
加入 9         |  1  1  0  1  1  0  0  0  0  1  1  0  1
```

如果**正序**就是以下结果：

```
物品↓ / 容量→   |  0  1  2  3  4  5  6  7  8  9 10 11 12
-------------------------------------------------------
初始           |  1  0  0  0  0  0  0  0  0  0  0  0  0
加入 1         |  1  1  0  0  0  0  0  0  0  0  0  0  0
加入 3         |  1  1  0  1  1  0  1  1  0  0  0  0  0
加入 9         |  1  1  0  1  1  0  1  1  0  1  1  0  1
```

### 代码

```cpp
class Solution {
public:
    bool checkPowersOfThree(int n) {
        if (n % 3 == 2) {
            return false;
        }
        vector<int> dp(n + 1, 0);
        dp[0] = 1;

        for (int i = 0; i < n; i++) {
            int pow3 = (int)pow(3, i);
            if (pow3 > n) break;

            for (int j = n; j >= pow3; j--) {
                dp[j] = dp[j] + dp[j - pow3];
            }
            // 打印这一轮更新后的 dp
            cout << "加入 " << pow3 << " 后的 dp: ";
            for (int k = 0; k <= n; k++) {
                cout << dp[k] << " ";
            }
            cout << endl;
        }
        return dp[n] > 0;
    }
};
```

### 复杂度分析

- 时间复杂度：O(log₃ n × n)
   因为物品数 ≈ log₃ n，容量为 n。
- 空间复杂度：O(n)

虽然复杂度比数学解法大很多，但这是**01 背包的经典练习**，特别适合学习动态规划的“状态转移”思想。

## 方法比较

| 方法      | 思路                | 时间复杂度  | 空间复杂度 |
| --------- | ------------------- | ----------- | ---------- |
| 3 进制法  | 检查 3 进制每位 ≤ 1 | O(log₃ n)   | O(1)       |
| 01 背包法 | 背包装满问题        | O(n log₃ n) | O(n)       |

