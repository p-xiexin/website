---
description: C++ RAII 在工程中的三大硬伤与应对
date: '2023-11-18'
author: 'pxx'
categories:
  - Program
published: true
---

# C++ RAII 的两个结构性缺陷

RAII（Resource Acquisition Is Initialization）把“构造 = 获取资源，析构 = 释放资源”当作核心约定。它确实解决了大量资源泄漏问题，但在工程实践里有两个几乎无法绕开的结构性缺陷，再加上构造/析构函数的异常语义，常常让理想与现实背离。下面用叙述性的方式把这些问题展开。

## 1. 构造函数很难很好表达“失败”
构造函数不能返回错误码，也无法天然携带 `expected<T, E>`；一旦失败，唯一出口就是抛异常。然而在嵌入式、游戏、内核、低延迟等场景，异常要么被禁用，要么成本过高。于是“把可能失败的事情放进构造里”在很多代码库中直接行不通。

更糟的是，构造抛出的异常意味着对象压根没建好，不会调用析构。所有已经拿到的子资源必须依赖成员或局部 RAII 托底，否则半初始化状态就会泄漏资源。这也是为什么许多团队宁可牺牲语义一致性，也要把重活挪到 `init()` 之类的显式初始化步骤：

```cpp
class File {
public:
    File() = default;
    bool init(const char* path) {
        fp = fopen(path, "r");
        return fp != nullptr; // 失败用返回值处理
    }
};
```
这种写法背离了“构造即初始化”，但在禁止异常的环境中，它是最实际的折中。

## 2. 观察指针/引用无法保证有效性
C++ 没有 Rust 式的借用检查，语言层面也缺少生命周期分析。“借”出去的引用、指针或迭代器，只要底层容器发生结构性修改，随时可能失效。

以 `std::vector` 为例，扩容会整体搬迁元素：
```cpp
std::vector<int> v = {1,2,3};
int& r = v[0];      // 绑定旧内存
v.push_back(4);     // 可能 reallocate
int x = r;          // r 已悬空，行为未定义
```
封装还会让这个问题更加隐蔽：
```cpp
class MyClass {
    std::vector<int> data;
public:
    int& get(size_t i) { return data[i]; }
    void add(int x) { data.push_back(x); }
};

auto& ref = m.get(0);
m.add(100);         // 隐含的 reallocate 风险
int x = ref;        // ref 已失效，调用者毫不知情
```
不仅是 `vector`，几乎所有可移动的容器都存在类似风险：`string` 的扩容与增删，`deque` 的段重组，甚至 C++17 前的 `map`/`set` 节点移动。语言没有任何机制阻止“借一个马上就会失效的引用”，诊断全靠工程师经验和规范。

## 3. 构造/析构抛异常会怎样
构造抛异常常被视为“初始化失败”的正常信号，但要记住：对象未构建完成，析构不会被调用，必须依赖成员或局部 RAII 来收尾，否则会泄漏。

析构则更加敏感。C++11 起未显式标记的析构函数默认 `noexcept(true)`，如果异常从析构泄漏出去，运行时会直接调用 `std::terminate`。你可以写成 `noexcept(false)` 允许抛出，但若此时正处于栈展开再抛第二个异常，同样会触发 `std::terminate`。因此惯例做法是：在析构内部捕获一切异常，记录或吞掉，绝不让它传播，把可失败的清理动作暴露为独立的 `close()`/`cleanup()` 接口由调用方显式处理。

## 小结
RAII 依旧是 C++ 管理资源的主力，但现实世界存在三条需要时刻记住的高压线：
1) 构造无法优雅处理失败，重初始化往往不得不迁到显式的 `init()`；
2) 引用/指针缺乏有效期保障，容器 reallocate 或结构变化会让“借用”瞬间失效；
3) 构造抛异常时必须有局部 RAII 托底，析构默认 `noexcept`，异常泄漏直接 `std::terminate`。

理解这些限制，才能在工程里把 RAII 用得既安全又可维护。
